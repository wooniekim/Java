# 상속
- "부모로부터 물려받는다."
- 물려받을 때는 일부분만 받는것이 아니라 통으로 다 물려받음
- 부모 클래스(수퍼클래스)
- 자식 클래스(서브 클래스)
- 공통적인 요소를 먼저 클래스로 만들고(부모클래스), 상속받아서 새로운 것만 추가(자식클래스)
- 객체 관계
    - is-a관계(Dog is a animal.) => dog가 자식, animal이 부모
    - has-a관계(Animal has a dog.)
- 상속은 is-a관계가 성립할 때만 사용하기
- 자식객체를 만들면 부모객체를 만듬(extends 사용시), 부모의 몸체가 자기 몸체의 일부분임
- 상속이 중복을 줄이는 이유
    - Car, Truck, Bus 클래스를 따로 만드는 경우 => 갯수가 늘어날수록 만들기가 귀찮음
    - Car, Truck, Bus 클래스의 공통점만 모아서 Vehicle 클래스를 만든 후 Car, Truck, Bus를 각각 Vehicle을 상속받아 만듬(확장성 부분에서 아주 좋음)

## 상속과 접근제어
- 부모를 만들때 자식한테 필요없는 요소가 있을수도 있음(Ex: 자식한테 비밀로 한 일)
- private : 자식에게도 공개안됨
- protected : 자식에게만 공개
- 자식객체를 생성하면 부모의 객체도 자동생성됨
- 기본생성자


## 메소드 재정의
- 메소드 오버라이딩(method overriding) : 재정의
    - 자식 클래스가 필요에 따라 상속된 메소드를 다시 정의하는 것(형식은 그대로 가져가고 내용 업데이트)
    - 나중에 호출할 때 재정의한 메소드에 우선권이 있음
    - 재정의 당한 메소드는 우선순위가 낮아짐

- 메소드 오버로딩 : 중복정의

## 상속과 생성자
- 추상클래스를 상속받으면 반드시 재정의 해야한다

- 추상클래스는 객체 생성 못함
- 자식타입과 부모타입중에 부모타입이 더 큼
- 상향형변환(Upcasting)

# 다형성(polymorphism)
- 객체지향 프로그래밍의 꽃
- 객체들의 타입이 다르면 똑같은 메시지가 전달되더라도 서로 다른 동작을 하는 것
- 확장성에 좋음

1. 제작자
    - 상속 구조
    - 재정의 포함해야함(overriding)
2. 사용자
    - 반드시 상향형변환(Upcasting) 해야함
    - 재정의된 메소드 호출 => 다형성 발생!!
3. 동적바인딩 제공 => 자바 기본 제공

- 물려준 것만

- 다운캐스팅
- 다양성

## 메소드의 매개 변수
- 메소드의 매개 변수로 부모 클래스 참조 변수를 이용한다
- 매개변수는 크게 가져가는게 좋다
- s instanceof Rectangle 
    - 오른쪽은 타입, 왼쪽은 실제 주소 반환값은 boolean 타입

## Object 클래스 
- 자바 클래스 계층 구조에서 맨 위에 위치하는 클래스
- equals(object obj) : obj가 현재 객체와 같은지를 반환, 재정의 하려면 다운캐스팅 해야함
- toString() : 객체를 기술하는 문자열을 반환

# 인터페이스
- 메소드에 대한 선언만 가지고 있다
- 클래스와 클래스 사이의 상호 작용의 규격을 나타낸 것이 인터페이스이다(표준)
- 인터페이스에는 몸체가 없는 추상 메소드만 정의됨
- implements


# 다형성(polymorphism) 성립조건
- 1. 클래스 제작
    - 상속 구조
    - 재정의(Overriding)
- 2. 클래스 사용
    - 업캐스팅(upcasting)
    - 재정의된 메소드 호출